#!/usr/bin/env python3
"""
crypt.py — encrypt or decrypt a file using AES-128 (ECB) and RSA key wrapping.

Usage:
  Encryption:
    ./crypt.py -e <public_key_file> <input_plaintext> <output_cipherfile>
  Decryption:
    ./crypt.py -d <private_key_file> <input_cipherfile> <output_plaintext>

Formats:
  • RSA key files (generated by genkeys.py) are simple text files:
        n=<modulus>
        e=<public exponent>   # for .pub
        d=<private exponent>  # for .prv
  • Cipherfile layout (raw binary):
      [4 bytes big‑endian length L of wrapped AES key K′]
      [L bytes: RSA‑encrypted AES key K′]
      [remaining bytes: AES‑128‑ECB ciphertext of the payload]
"""

import sys
import os
from Crypto.Cipher import AES

def read_keyfile(path):
    """Read RSA key components from a text file into a dict of ints."""
    comps = {}
    with open(path, 'r') as f:
        for line in f:
            if '=' in line:
                k, v = line.strip().split('=', 1)
                comps[k] = int(v)
    return comps

def pad_zero(data, block_size=16):
    """Zeropad data to a multiple of block_size."""
    pad_len = (-len(data)) % block_size
    return data + b'\x00' * pad_len

def unpad_zero(data):
    """Remove trailing zero bytes."""
    return data.rstrip(b'\x00')

def encrypt_file(pubkey_path, plaintext_path, cipher_path):
    # 1) Generate a random 16‑byte AES‑128 key K
    K = os.urandom(16)
    K_int = int.from_bytes(K, 'big')

    # 2) Load RSA public key (n, e)
    pub = read_keyfile(pubkey_path)
    n, e = pub['n'], pub['e']

    # 3) RSA‑encrypt K → K′ = K^e mod n
    K_enc_int = pow(K_int, e, n)
    # Serialize K′ as a fixed byte length = ceil(bitlen(n)/8)
    k_len = (n.bit_length() + 7) // 8
    K_enc = K_enc_int.to_bytes(k_len, 'big')

    # 4) Read plaintext and AES‑encrypt in ECB mode (zero‑padding)
    with open(plaintext_path, 'rb') as f:
        pt = f.read()
    cipher = AES.new(K, AES.MODE_ECB)
    ct = cipher.encrypt(pad_zero(pt))

    # 5) Write out: [4‑byte L][K′][ciphertext]
    with open(cipher_path, 'wb') as f:
        f.write(len(K_enc).to_bytes(4, 'big'))
        f.write(K_enc)
        f.write(ct)

    print(f"Encrypted '{plaintext_path}' → '{cipher_path}' using AES‑128 + RSA key wrap.")

def decrypt_file(prvkey_path, cipher_path, plaintext_path):
    # 1) Load RSA private key (n, d)
    prv = read_keyfile(prvkey_path)
    n, d = prv['n'], prv['d']

    # 2) Read the cipherfile
    with open(cipher_path, 'rb') as f:
        data = f.read()

    # 3) Parse length and wrapped key
    L = int.from_bytes(data[:4], 'big')
    K_enc = data[4:4+L]
    ct = data[4+L:]

    # 4) RSA‑decrypt K′ → K = (K′)^d mod n
    K_enc_int = int.from_bytes(K_enc, 'big')
    K_int = pow(K_enc_int, d, n)
    K = K_int.to_bytes(16, 'big')  # AES‑128 key

    # 5) AES‑decrypt and remove zero‑padding
    cipher = AES.new(K, AES.MODE_ECB)
    pt_padded = cipher.decrypt(ct)
    pt = unpad_zero(pt_padded)

    # 6) Write plaintext
    with open(plaintext_path, 'wb') as f:
        f.write(pt)

    print(f"Decrypted '{cipher_path}' → '{plaintext_path}' using RSA‑unwrap + AES‑128.")

def usage_and_exit():
    print("Usage:")
    print("  To encrypt: ./crypt.py -e <public_key> <infile> <outfile>")
    print("  To decrypt: ./crypt.py -d <private_key> <infile> <outfile>")
    sys.exit(1)

def main():
    if len(sys.argv) != 5:
        usage_and_exit()

    mode, keyfile, infile, outfile = sys.argv[1:]
    if mode == '-e':
        encrypt_file(keyfile, infile, outfile)
    elif mode == '-d':
        decrypt_file(keyfile, infile, outfile)
    else:
        usage_and_exit()

if __name__ == '__main__':
    main()
